/**
 * 洗牌算法：
 * 1.背景：笔试时的算法题，在 n 个不同的数中随机取出不重复的 m 个数。
 * 洗牌算法是将原来的数组进行打散，使原数组的某个数在打散后的数组中的每个位置上等概率的出现，刚好可以解决上面出现的问题
 * 
 * 2. 洗牌算法由抽牌，换牌和插排衍生出三种洗牌算法，其中抽牌和换牌分别对应 Fisher-Yates Shuffle 和 Knuth-Durstenfeld Shuffle 算法。
 */

 /**
  * 抽牌算法
  * Fisher-Yates Shuffle算法：基本思路是从原始数组中随机取出一个之前没有取到的数组到新数组中，具体如下：
  * 1. 初始化原始数组和新数组，原始数组长度为 n(已知)。
  * 2. 从还没处理的数组(假如还剩 k 个)中，随机产生一个 [0, k)之间的数字 p (假设数组从 0 开始)
  * 3. 从剩下的 k 个数中把第 p 个数取出。
  * 4. 重复步骤 2 和 3直到数字全部取完。
  * 5. 从步骤 3 取出来的数字序列就是一个打乱了的数列。
  * 证明其随机性，即每个元素被放置在新数组中的第 i 个 位置的概率是 1/n (假设数组大小是 n).
  * 证明： 一个元素 m 被放入第 i 个位置的概率为 P = 前 i-1 个位置选择元素时没有选中m的概率 * 第i个位置选中m的概率，即为：
  * p = (n-1)/n * (n-2)/(n-1) * ... * (n-i+1)/(n-i+2) * 1/(n-i+1) = 1/n
  * 
  * 时间复杂度：O(n^2)
  * 空间复杂度：O(n)
  */
 function shuffle_pick(nums) {
     var result = [];
     for (var i = 0; i < nums.length; i++ ) {
         var rand = parseInt(Math.random() * nums.length);
         result.push(nums[rand]);
         nums.splice(rand, 1);
     }
     return result;
 }

 /**
  * 换牌算法
  * Knuth-Durstenfeld Shuffle算法：在Fisher算法的基础上进行了改进，在原始数组上对数字进行交互，省去了额外O(n)的空间。
  * 算法思路和Fisher类似，每次从未处理的数据中随机取出一个数字，然后把该数字放在数组的尾部，即数组尾部存放的是已经处理过的数字。
  * 算法思路如下：
  * 1. 生成一个从 0 到 n-1的随机数 x;
  * 2. 输出 arr 下标为 x 的数值，即为第一个随机数
  * 3. 将 arr 的尾元素和下标为 x 的元素互换
  * 4. 同1，生成一个从 0 到 n-2 的随机数 x
  * 5. 输出 arr 下标为x的数值，为第二个随机数
  * 6. 将 arr的倒数第二个元素和下标为x 的元素互换。
  * 7. 直到输出 m 个数为止
  * 证明：对于 arr[i]，洗牌后在第 n-1 个位置的概率是 1/n （第一次交换的随机数为i）
  * arr[i]在 n-2 个位置的概率是(n-1)/n * 1/(n-1) = 1/n,（第一次交换的随机数不为 i, 第二次为arr[i]所在的位置）
  * arr[i]在第 n-k 个位置上的概率为p = (n-1)/n * (n-2)/(n-1)* ... * 1/(n-k+1) = 1/n;
  * 
  * 优点：不需要额外占用对于的数组空间
  * 缺点：
  * 1. 必须知道数组长度，无法处理长度不固定的数组
  * 2. 改变了原数组的排列顺序
  * 3. 由于扫描的方式是从后往前，因此无法处理长度动态增长的数组
  * 
  * 时间复杂度：O(n)
  * 空间复杂度：O(1)
  */

  function shuffle_wrap(nums) {
      for (var i = nums.length - 1; i >= 0; --i){
          var rand = parseInt(Math.random() * (i + 1));
          var tmp = nums[rand];
          nums[rand] = nums[i];
          nums[i] = tmp;
      }
  }

  /**
   * 插牌算法
   * 换牌算法是一个内部打乱的算法，算法完成后原始数据被直接打乱。尽管这个方法可以节省空间，但在有些应用中可能需要保留原始数据，所以需要另外开辟一个数组来存储生成的新序列。
   * 插排算法的基本思想是从前往后扫描数据，把位置i的数据随机插入到前 i 个(包括第i个)位置中
   */

   function shuffle_insert(nums) {

   }